/**
 * FontJit v1.0.1
 * by Roel Nieskens - pixelambacht.nl
 */
export const LoadingState={UNLOADED:"unloaded",LOADING:"loading",LOADED:"loaded",ERROR:"error"};const fontCache=new Map,createCacheKey=(t,e,a)=>{const o=Object.entries(a).sort(([t],[e])=>t.localeCompare(e));return`${t}::${e}::${JSON.stringify(o)}`},getElements=t=>"string"==typeof t?document.querySelectorAll(t):t instanceof Element?[t]:t,loadFont=t=>{const e=getElements(t);e.forEach(t=>{const e=t.getAttribute("data-fontjit-status");if(e===LoadingState.LOADING||e===LoadingState.LOADED)return;const a=t.getAttribute("data-fontjit-url"),o=t.getAttribute("data-fontjit-name");if(!a||!o)return void t.setAttribute("data-fontjit-status",LoadingState.ERROR);let n={};const r=t.getAttribute("data-fontjit-descriptors");if(r)try{n=JSON.parse(r)}catch(t){console.error(t)}const s=createCacheKey(o,a,n);let i=fontCache.get(s);if(!i){const t=new FontFace(o,`url("${a}")`,n);i=t.load().then(t=>(document.fonts.add(t),t)).catch(t=>{throw fontCache.delete(s),t}),fontCache.set(s,i)}t.setAttribute("data-fontjit-status",LoadingState.LOADING),i.then(()=>{t.setAttribute("data-fontjit-status",LoadingState.LOADED)}).catch(()=>{t.setAttribute("data-fontjit-status",LoadingState.ERROR)})})};export const fontJit=(t,e={})=>{const{immediate:a=!1,...o}=e;if(a)return void loadFont(t);const n=getElements(t),r=new IntersectionObserver(t=>{t.forEach(t=>{t.isIntersecting&&(loadFont(t.target),r.unobserve(t.target))})},o);n.forEach(t=>{t.setAttribute("data-fontjit-status",LoadingState.UNLOADED),r.observe(t)})};