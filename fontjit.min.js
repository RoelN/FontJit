/**
 * FontJit v1.1.0
 * by Roel Nieskens - pixelambacht.nl
 */
export const LoadingState={UNLOADED:"unloaded",LOADING:"loading",LOADED:"loaded",ERROR:"error"};const fontCache=new Map,elementResolvers=new WeakMap,createCacheKey=(e,t,n)=>{const s=Object.entries(n).sort(([e],[t])=>e.localeCompare(t));return`${e}::${t}::${JSON.stringify(s)}`},getElements=e=>typeof e=="string"?document.querySelectorAll(e):e instanceof Element?[e]:e,loadFont=e=>{const t=getElements(e);t.forEach(e=>{const a=e.getAttribute("data-fontjit-status");if(a===LoadingState.LOADED){elementResolvers.get(e)?.resolve();return}if(a===LoadingState.LOADING)return;const n=e.getAttribute("data-fontjit-url"),s=e.getAttribute("data-fontjit-name");if(!n||!s){e.setAttribute("data-fontjit-status",LoadingState.ERROR);return}let o={};const r=e.getAttribute("data-fontjit-descriptors");if(r)try{o=JSON.parse(r)}catch(e){console.error(e)}const i=createCacheKey(s,n,o);let t=fontCache.get(i);if(!t){const e=new FontFace(s,`url("${n}")`,o);t=e.load().then(e=>(document.fonts.add(e),e)).catch(e=>{throw fontCache.delete(i),e}),fontCache.set(i,t)}e.setAttribute("data-fontjit-status",LoadingState.LOADING),t.then(()=>{e.setAttribute("data-fontjit-status",LoadingState.LOADED),elementResolvers.get(e)?.resolve()}).catch(t=>{e.setAttribute("data-fontjit-status",LoadingState.ERROR),elementResolvers.get(e)?.reject(t)})})};export const fontJit=(e="[data-fontjit-url]",t={})=>{const{immediate:i=!1,...a}=t,n=getElements(e),s=[];if(n.forEach(e=>{const t=e.getAttribute("data-fontjit-url"),n=e.getAttribute("data-fontjit-name"),o=new Promise((s,o)=>{if(!t||!n){e.setAttribute("data-fontjit-status",LoadingState.ERROR),o();return}elementResolvers.set(e,{resolve:s,reject:o})});s.push(o)}),i)return loadFont(n),Promise.all(s);const o=new IntersectionObserver(e=>{e.forEach(e=>{e.isIntersecting&&(loadFont(e.target),o.unobserve(e.target))})},a);return n.forEach(e=>{e.setAttribute("data-fontjit-status",LoadingState.UNLOADED),o.observe(e)}),Promise.all(s)}